package workerstatemachine

import (
	"fmt"
	"sync"
	"time"

	"github.com/core-tools/hsu-master/pkg/errors"
	"github.com/core-tools/hsu-master/pkg/logging"
)

// WorkerState represents the current state of a worker in its lifecycle
type WorkerState string

const (
	// WorkerStateUnknown is the initial state before worker registration
	WorkerStateUnknown WorkerState = "unknown"

	// WorkerStateRegistered means worker is added to master but not started
	WorkerStateRegistered WorkerState = "registered"

	// WorkerStateStarting means worker start operation is in progress
	WorkerStateStarting WorkerState = "starting"

	// WorkerStateRunning means worker is running normally
	WorkerStateRunning WorkerState = "running"

	// WorkerStateStopping means worker stop operation is in progress
	WorkerStateStopping WorkerState = "stopping"

	// WorkerStateStopped means worker stopped cleanly
	WorkerStateStopped WorkerState = "stopped"

	// WorkerStateFailed means worker failed to start or crashed
	WorkerStateFailed WorkerState = "failed"

	// WorkerStateRestarting means worker restart operation is in progress
	WorkerStateRestarting WorkerState = "restarting"
)

// WorkerStateTransition represents a state transition with metadata
type WorkerStateTransition struct {
	From      WorkerState
	To        WorkerState
	Operation string
	Timestamp time.Time
	Error     error
}

// WorkerStateMachine manages worker state transitions with validation
type WorkerStateMachine struct {
	workerID         string
	currentState     WorkerState
	transitions      []WorkerStateTransition
	validTransitions map[WorkerState][]WorkerState
	mutex            sync.RWMutex
	logger           logging.Logger
}

// NewWorkerStateMachine creates a new worker state machine
func NewWorkerStateMachine(workerID string, logger logging.Logger) *WorkerStateMachine {
	wsm := &WorkerStateMachine{
		workerID:     workerID,
		currentState: WorkerStateUnknown,
		transitions:  make([]WorkerStateTransition, 0),
		mutex:        sync.RWMutex{},
		logger:       logger,
	}

	// Define valid state transitions
	wsm.validTransitions = map[WorkerState][]WorkerState{
		WorkerStateUnknown: {
			WorkerStateRegistered, // AddWorker
		},
		WorkerStateRegistered: {
			WorkerStateStarting, // StartWorker
		},
		WorkerStateStarting: {
			WorkerStateRunning, // start success
			WorkerStateFailed,  // start failure
		},
		WorkerStateRunning: {
			WorkerStateStopping,   // StopWorker
			WorkerStateFailed,     // process crash
			WorkerStateRestarting, // RestartWorker
		},
		WorkerStateStopping: {
			WorkerStateStopped, // stop success
			WorkerStateFailed,  // stop failure
		},
		WorkerStateStopped: {
			WorkerStateStarting, // restart after clean stop
		},
		WorkerStateFailed: {
			WorkerStateStarting, // retry after failure
		},
		WorkerStateRestarting: {
			WorkerStateRunning, // restart success
			WorkerStateFailed,  // restart failure
		},
	}

	return wsm
}

// GetCurrentState returns the current state of the worker (thread-safe)
func (wsm *WorkerStateMachine) GetCurrentState() WorkerState {
	wsm.mutex.RLock()
	defer wsm.mutex.RUnlock()
	return wsm.currentState
}

// CanTransition checks if a transition from current state to target state is valid (thread-safe)
func (wsm *WorkerStateMachine) CanTransition(to WorkerState) bool {
	wsm.mutex.RLock()
	defer wsm.mutex.RUnlock()

	validStates, exists := wsm.validTransitions[wsm.currentState]
	if !exists {
		return false
	}

	for _, validState := range validStates {
		if validState == to {
			return true
		}
	}
	return false
}

// Transition attempts to transition to a new state (thread-safe)
func (wsm *WorkerStateMachine) Transition(to WorkerState, operation string, err error) error {
	wsm.mutex.Lock()
	defer wsm.mutex.Unlock()

	if !wsm.canTransitionUnsafe(to) {
		return errors.NewValidationError(
			fmt.Sprintf("invalid state transition from %s to %s", wsm.currentState, to),
			nil,
		).WithContext("worker_id", wsm.workerID).
			WithContext("current_state", string(wsm.currentState)).
			WithContext("target_state", string(to)).
			WithContext("operation", operation)
	}

	// Record transition
	transition := WorkerStateTransition{
		From:      wsm.currentState,
		To:        to,
		Operation: operation,
		Timestamp: time.Now(),
		Error:     err,
	}

	wsm.transitions = append(wsm.transitions, transition)
	wsm.currentState = to

	wsm.logger.Debugf("Worker state transition: %s -> %s (operation: %s), worker: %s",
		transition.From, transition.To, operation, wsm.workerID)

	return nil
}

// canTransitionUnsafe checks if a transition is valid (assumes lock is held)
func (wsm *WorkerStateMachine) canTransitionUnsafe(to WorkerState) bool {
	validStates, exists := wsm.validTransitions[wsm.currentState]
	if !exists {
		return false
	}

	for _, validState := range validStates {
		if validState == to {
			return true
		}
	}
	return false
}

// ValidateOperation checks if an operation is allowed in the current state
func (wsm *WorkerStateMachine) ValidateOperation(operation string) error {
	wsm.mutex.RLock()
	defer wsm.mutex.RUnlock()

	switch operation {
	case "start":
		if wsm.currentState == WorkerStateRegistered || wsm.currentState == WorkerStateStopped || wsm.currentState == WorkerStateFailed {
			return nil
		}
		return errors.NewValidationError(
			fmt.Sprintf("cannot start worker in state %s", wsm.currentState),
			nil,
		).WithContext("worker_id", wsm.workerID).
			WithContext("current_state", string(wsm.currentState)).
			WithContext("operation", operation)

	case "stop":
		if wsm.currentState == WorkerStateRunning {
			return nil
		}
		return errors.NewValidationError(
			fmt.Sprintf("cannot stop worker in state %s", wsm.currentState),
			nil,
		).WithContext("worker_id", wsm.workerID).
			WithContext("current_state", string(wsm.currentState)).
			WithContext("operation", operation)

	case "restart":
		if wsm.currentState == WorkerStateRunning {
			return nil
		}
		return errors.NewValidationError(
			fmt.Sprintf("cannot restart worker in state %s", wsm.currentState),
			nil,
		).WithContext("worker_id", wsm.workerID).
			WithContext("current_state", string(wsm.currentState)).
			WithContext("operation", operation)

	case "remove":
		if wsm.currentState == WorkerStateStopped || wsm.currentState == WorkerStateFailed {
			return nil
		}
		return errors.NewValidationError(
			fmt.Sprintf("cannot remove worker in state %s (must be stopped or failed)", wsm.currentState),
			nil,
		).WithContext("worker_id", wsm.workerID).
			WithContext("current_state", string(wsm.currentState)).
			WithContext("operation", operation)

	default:
		return errors.NewValidationError(
			fmt.Sprintf("unknown operation: %s", operation),
			nil,
		).WithContext("worker_id", wsm.workerID).
			WithContext("operation", operation)
	}
}

// GetTransitionHistory returns the history of state transitions (thread-safe)
func (wsm *WorkerStateMachine) GetTransitionHistory() []WorkerStateTransition {
	wsm.mutex.RLock()
	defer wsm.mutex.RUnlock()

	// Return a copy to prevent external modification
	history := make([]WorkerStateTransition, len(wsm.transitions))
	copy(history, wsm.transitions)
	return history
}

// GetStateInfo returns detailed state information (thread-safe)
func (wsm *WorkerStateMachine) GetStateInfo() map[string]interface{} {
	wsm.mutex.RLock()
	defer wsm.mutex.RUnlock()

	return map[string]interface{}{
		"worker_id":         wsm.workerID,
		"current_state":     wsm.currentState,
		"transition_count":  len(wsm.transitions),
		"valid_transitions": wsm.validTransitions[wsm.currentState],
	}
}

// IsOperationAllowed checks if a specific operation is allowed in the current state
func (wsm *WorkerStateMachine) IsOperationAllowed(operation string) bool {
	return wsm.ValidateOperation(operation) == nil
}
